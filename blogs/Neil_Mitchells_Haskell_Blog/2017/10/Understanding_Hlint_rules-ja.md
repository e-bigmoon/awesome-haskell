# HLint のルールを理解する

*概要: 新しいバージョンの HLint で foldr を map に変えてヒントを提示するルールを追加したので、それがどうやって動いているのかを説明する。*

[HLint 2.0.10](https://hackage.haskell.org/package/hlint-2.0.10) がリリースされました。これには、本当は `map` を使うべきところで使われている `foldr` を認識するようなルールが含まれています。例:

```haskell
foldr (\curr acc -> (+1) curr : acc) []
```

これは、以下のように書き換えることができます:

```haskell
map (\curr -> (+1) curr)
```

こっちの方がずっと読みやすいですね (続いて、HLint は `map (+1)` を提案します。最初の `foldr` よりもかなり読みやすくなっています)。これを達成するためには、[hlint.yaml](https://github.com/ndmitchell/hlint/blob/master/data/hlint.yaml) に以下のルールを追加する必要がありました。

```yaml
- warn: {lhs: "foldr (\\c a -> x : a) []", rhs: "map (\\c -> x)"}
```

この一文は、`foldr (\c a -> x : a) []` を見たときに、`map (\c -> x)` を警告で提案する、という意味です。次に、マッチする HLint のエンジンは、このテンプレートをプログラム中の全ての部分式に適用します。ここからは、そのときに HLint が取るステップを説明していきます。

## ステップ1: 単一化
最初のステップは、`foldr (\c a -> x : a) []` というテンプレートの単一化です。`foldr (\curr acc -> (+1) curr : acc) []` のような、ユーザの部分式に対して行われます。HLint はテンプレート中の 1文字の変数 (c, a, x など) への代入ができる部分を探していき、部分式にマッチさせようとします。この単一化はトップダウンで進行し、マッチしないものが現れた段階で (例えば `foldl` など) その単一化は失敗します。このとき、以下のような変数のバインドの単一化は成功します:

* `c = curr` (ラムダ式の最初の引数)
* `a = acc` (ラムダ式の第2引数)
* `x = (+1) curr` (cons の前)
* `a = acc` (cons の後)

しかし、`foldl (\curr acc -> (+1) curr : acc) []` のような部分式の単一化は失敗します。

## ステップ2: 妥当性のチェック
次のステップは、1回以上バインドされている変数が、全てのバインディングで等しくなっているかどうかのチェックです。さっきの例では、`a` だけが 2回使われており、常に `acc` にバインドされていました。そのため、この単一化は妥当です。

逆に妥当ではない部分式は `foldr (\curr acc -> (+1) curr : xs) []` のようなものです。

## ステップ3: 置換
バインドが確定したので、それを RHS (等式の右部分) に置換することができます。具体的には、`map (\c -> x)` への変換です。`c` と `x` を例中のバインドで置換します。ちなみに、`a` は RHS の中では登場しないので使いません。置換後は以下のようになります:

```haskell
map (\curr -> (+1) curr)
```
